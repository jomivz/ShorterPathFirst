Le répertoire suivant contient les sources et binaires d'un programme
algorithmique sur les plus courts chemins. Il a été développé dans le 
cadre des travaux pratiques au cours de mon Master Informatique. 

===================
Compilation
===================
Pour compiler le programme, il faut posséder le compilateur gcc.
Placez vous dans le répertoire et lancez les commandes suivantes:

[~ src]$ make clean
[~ src]$ make 

La premiere commande permet de supprimer les fichiers objets et
binaires.

===================
Execution
===================
Pour l'execution, il suffit de lancer le binaire 'main' dans le 
sous-répertoire './bin'. Pour l'ensemble des executions, il est 
important de rester dans le repertoire parent.

[~ src]$ ./bin/main/

===================
Utilisation
===================
Un menu interactif s'affiche. Le déroulement se passe en deux étapes:
 1. choisir l'algorithme
 2. choisir le fichier source graphe

Trois algorithmes ont été implémentés:
 1. Ford-Bellman: en complexite de O(n2), efficace sur des graphes creux
 2. Dijkstra: en complexite de O(n2), efficace sur des graphes complets
 3. Dijkstra par tas: en complexite de O(nlogn)
Un chronometre permet de voir le temps de calcul des plus courts chemins
ayant pour source le sommet '1'. Ce sommet est placé en dur dans le code.
Pour afficher un plus court chemin, il est necessaire d'indiquer le puit.

Les fichiers sources peuvent être fait manuellement ou par un générateur.
Leur structure est simple, chaque ligne represente une arete de la 
maniere suivante:
 sommet1 sommet2 poids
Le poids correspond au cout de passage sur l'arete.

L'affichage d'un graphe est basée sur les listes d'adjacences. La 
premiere colonne represente les sommets, les autres les sucesseurs du 
sommet correspondant.

===================
Evolution
===================
Une amélioration peut être concernant l'implementation des graphes,
actuellement sous forme matricielle. Ce qui n'est pas optimisé pour 
les graphes creux (ex du pire cas: une chaine a n sommets et n-1 aretes).
La matrice sera rempli de zero et la recherche ne sera pas optimisé.
Ce n'est le but du TP qui de voir la complexite des algos donc sur de
gros graphes. Pour cette amélioration, il est possible selon le rapport
(nb aretes/nb sommet) de choisir une implémentation en liste d'adjacence
ou matricielle.

===================
Remerciements
===================
Je tiens a remercier Jeremy Soulary pour sa collaboration en tant que
bînome, notamment pour le générateur de graphes aléatoires. Je remercie
également Mr Rodolph Giroudeau pour son enseignement et son encadrement.
